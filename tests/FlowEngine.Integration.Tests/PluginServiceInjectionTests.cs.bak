using FlowEngine.Abstractions.Data;
using FlowEngine.Abstractions.Factories;
using FlowEngine.Abstractions.Plugins;
using FlowEngine.Core;
using FlowEngine.Core.Plugins;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Phase3TemplatePlugin;
using Xunit;
using Xunit.Abstractions;

namespace FlowEngine.Integration.Tests;

/// <summary>
/// Integration tests for plugin loading with comprehensive service injection.
/// Tests the complete plugin lifecycle with dependency injection, error handling, and discovery.
/// </summary>
public class PluginServiceInjectionTests : IDisposable
{
    private readonly ITestOutputHelper _output;
    private readonly ServiceProvider _serviceProvider;
    private readonly IPluginLoader _pluginLoader;
    private readonly IPluginDiscoveryService _discoveryService;
    private readonly IPluginManager _pluginManager;
    private readonly string _templatePluginAssemblyPath;

    public PluginServiceInjectionTests(ITestOutputHelper output)
    {
        _output = output;

        // Configure comprehensive service provider
        var services = new ServiceCollection();
        services.AddLogging(builder => 
        {
            builder.AddConsole();
            builder.SetMinimumLevel(LogLevel.Debug);
        });

        // Add all FlowEngine services
        services.AddFlowEngine();

        // Add plugin-specific services
        services.AddTransient<TemplatePlugin>();
        services.AddTransient<TemplatePluginService>();
        services.AddTransient<TemplatePluginValidator>();

        _serviceProvider = services.BuildServiceProvider();
        _pluginLoader = _serviceProvider.GetRequiredService<IPluginLoader>();
        _discoveryService = _serviceProvider.GetRequiredService<IPluginDiscoveryService>();
        _pluginManager = _serviceProvider.GetRequiredService<IPluginManager>();

        // Get path to template plugin assembly
        _templatePluginAssemblyPath = typeof(TemplatePlugin).Assembly.Location;
        
        _output.WriteLine($"Test setup complete. Template plugin assembly: {_templatePluginAssemblyPath}");
    }

    [Fact]
    public async Task LoadPlugin_WithServiceInjection_ShouldCreateInstanceWithAllDependencies()
    {
        // Arrange
        _output.WriteLine("Test: Loading plugin with service injection");

        // Act
        var plugin = await _pluginLoader.LoadPluginAsync<IPlugin>(
            _templatePluginAssemblyPath,
            typeof(TemplatePlugin).FullName!);

        // Assert
        Assert.NotNull(plugin);
        Assert.IsType<TemplatePlugin>(plugin);

        var templatePlugin = (TemplatePlugin)plugin;
        
        // Verify the plugin was created with proper dependency injection
        Assert.NotNull(templatePlugin.Id);
        Assert.NotEmpty(templatePlugin.Id);
        Assert.Equal("Phase3TemplatePlugin", templatePlugin.Name);

        _output.WriteLine($"Successfully loaded plugin: {templatePlugin.Name} (ID: {templatePlugin.Id})");
        _output.WriteLine($"Plugin lifecycle state: {templatePlugin.LifecycleState}");
    }

    [Fact]
    public async Task LoadPlugin_WithConfiguration_ShouldInitializeCorrectly()
    {
        // Arrange
        _output.WriteLine("Test: Loading and configuring plugin");

        var configuration = new TemplatePluginConfiguration
        {
            RowCount = 1000,
            BatchSize = 100,
            DataType = "TestData",
            DelayMs = 0
        };

        // Act
        var plugin = await _pluginLoader.LoadPluginAsync<IPlugin>(
            _templatePluginAssemblyPath,
            typeof(TemplatePlugin).FullName!);

        var templatePlugin = (TemplatePlugin)plugin;
        await templatePlugin.InitializeAsync(configuration);

        // Assert
        Assert.Equal(PluginLifecycleState.Initialized, templatePlugin.LifecycleState);
        Assert.Equal(configuration.RowCount, templatePlugin.Configuration?.RowCount);
        Assert.Equal(configuration.BatchSize, templatePlugin.Configuration?.BatchSize);
        Assert.Equal(configuration.DataType, templatePlugin.Configuration?.DataType);

        _output.WriteLine($"Plugin configured successfully:");
        _output.WriteLine($"  RowCount: {templatePlugin.Configuration?.RowCount}");
        _output.WriteLine($"  BatchSize: {templatePlugin.Configuration?.BatchSize}");
        _output.WriteLine($"  DataType: {templatePlugin.Configuration?.DataType}");
    }

    [Fact]
    public async Task LoadPlugin_WithServiceValidation_ShouldHaveAllRequiredServices()
    {
        // Arrange
        _output.WriteLine("Test: Validating plugin service injection");

        // Act
        var plugin = await _pluginLoader.LoadPluginAsync<IPlugin>(
            _templatePluginAssemblyPath,
            typeof(TemplatePlugin).FullName!);

        var templatePlugin = (TemplatePlugin)plugin;

        // Initialize to verify service dependencies work
        var configuration = new TemplatePluginConfiguration
        {
            RowCount = 10,
            BatchSize = 5,
            DataType = "TestData"
        };

        await templatePlugin.InitializeAsync(configuration);

        // Verify services are available by testing operations that require them
        var factories = _serviceProvider.GetServices<ISchemaFactory>();
        var arrayRowFactories = _serviceProvider.GetServices<IArrayRowFactory>();
        var chunkFactories = _serviceProvider.GetServices<IChunkFactory>();
        var datasetFactories = _serviceProvider.GetServices<IDatasetFactory>();

        // Assert
        Assert.NotEmpty(factories);
        Assert.NotEmpty(arrayRowFactories);
        Assert.NotEmpty(chunkFactories);
        Assert.NotEmpty(datasetFactories);

        _output.WriteLine("Service injection validation successful:");
        _output.WriteLine($"  Schema factories: {factories.Count()}");
        _output.WriteLine($"  ArrayRow factories: {arrayRowFactories.Count()}");
        _output.WriteLine($"  Chunk factories: {chunkFactories.Count()}");
        _output.WriteLine($"  Dataset factories: {datasetFactories.Count()}");
    }

    [Fact]
    public async Task PluginDiscovery_WithManifestFile_ShouldDiscoverTemplatePlugin()
    {
        // Arrange
        _output.WriteLine("Test: Plugin discovery with manifest");

        var pluginDirectory = Path.GetDirectoryName(_templatePluginAssemblyPath)!;

        // Act
        var discoveredPlugins = await _discoveryService.DiscoverPluginsAsync(pluginDirectory);

        // Assert
        Assert.NotEmpty(discoveredPlugins);
        
        var templatePluginManifest = discoveredPlugins.FirstOrDefault(p => 
            p.Id == "phase3-template-plugin");

        Assert.NotNull(templatePluginManifest);
        Assert.Equal("Phase 3 Template Plugin", templatePluginManifest.Name);
        Assert.Equal("3.0.0", templatePluginManifest.Version);
        Assert.Equal("Source", templatePluginManifest.PluginType);
        Assert.NotEmpty(templatePluginManifest.AssemblyPath);

        _output.WriteLine($"Discovered plugin: {templatePluginManifest.Name}");
        _output.WriteLine($"  ID: {templatePluginManifest.Id}");
        _output.WriteLine($"  Version: {templatePluginManifest.Version}");
        _output.WriteLine($"  Type: {templatePluginManifest.PluginType}");
        _output.WriteLine($"  Assembly: {Path.GetFileName(templatePluginManifest.AssemblyPath)}");
    }

    [Fact]
    public async Task PluginManager_WithRegistrationAndRetrieval_ShouldManagePluginLifecycle()
    {
        // Arrange
        _output.WriteLine("Test: Plugin manager lifecycle management");

        var pluginDirectory = Path.GetDirectoryName(_templatePluginAssemblyPath)!;

        // Act - Discover and register plugins
        await _pluginManager.DiscoverAndRegisterPluginsAsync(pluginDirectory);

        var registeredPlugins = _pluginManager.GetRegisteredPlugins();
        Assert.NotEmpty(registeredPlugins);

        var templatePluginInfo = registeredPlugins.FirstOrDefault(p => 
            p.Id == "phase3-template-plugin");
        Assert.NotNull(templatePluginInfo);

        // Load the plugin through the manager
        var plugin = await _pluginManager.LoadPluginAsync<ISourcePlugin>(templatePluginInfo.Id);
        Assert.NotNull(plugin);

        var loadedPlugins = _pluginManager.GetLoadedPlugins();
        Assert.Contains(loadedPlugins, p => p.Id == templatePluginInfo.Id);

        // Test plugin configuration
        var configuration = new TemplatePluginConfiguration
        {
            RowCount = 5,
            BatchSize = 5,
            DataType = "Integration Test Data"
        };

        await plugin.InitializeAsync(configuration);
        Assert.Equal(PluginLifecycleState.Initialized, plugin.LifecycleState);

        // Test plugin execution
        await plugin.StartAsync();
        Assert.Equal(PluginLifecycleState.Running, plugin.LifecycleState);

        // Cleanup
        await plugin.StopAsync();
        Assert.Equal(PluginLifecycleState.Stopped, plugin.LifecycleState);

        // Assert
        _output.WriteLine("Plugin manager lifecycle test completed successfully:");
        _output.WriteLine($"  Registered plugins: {registeredPlugins.Count()}");
        _output.WriteLine($"  Loaded plugins: {loadedPlugins.Count()}");
        _output.WriteLine($"  Plugin final state: {plugin.LifecycleState}");
    }

    [Fact]
    public async Task PluginExecution_WithDataProcessing_ShouldProcessDataSuccessfully()
    {
        // Arrange
        _output.WriteLine("Test: End-to-end plugin data processing");

        var plugin = await _pluginLoader.LoadPluginAsync<ISourcePlugin>(
            _templatePluginAssemblyPath,
            typeof(TemplatePlugin).FullName!);

        var configuration = new TemplatePluginConfiguration
        {
            RowCount = 10,
            BatchSize = 5,
            DataType = "Test Processing Data"
        };

        await plugin.InitializeAsync(configuration);

        // Act - Execute plugin processing
        await plugin.StartAsync();
        
        var processedData = new List<IChunk>();
        var cancellationToken = new CancellationTokenSource(TimeSpan.FromSeconds(10)).Token;

        try
        {
            await foreach (var chunk in plugin.ProduceAsync(cancellationToken))
            {
                processedData.Add(chunk);
                _output.WriteLine($"Received chunk with {chunk.RowCount} rows");
                
                // Break after receiving expected chunks to avoid infinite generation
                if (processedData.Sum(c => c.RowCount) >= configuration.RowCount)
                {
                    break;
                }
            }
        }
        catch (OperationCanceledException)
        {
            _output.WriteLine("Plugin processing completed or timed out");
        }

        await plugin.StopAsync();

        // Assert
        Assert.NotEmpty(processedData);
        var totalRows = processedData.Sum(c => c.RowCount);
        Assert.True(totalRows > 0, "Should have processed at least some data");

        _output.WriteLine($"Data processing test completed:");
        _output.WriteLine($"  Chunks processed: {processedData.Count}");
        _output.WriteLine($"  Total rows: {totalRows}");
        _output.WriteLine($"  Expected rows: {configuration.RowCount}");
    }

    [Fact]
    public async Task PluginLoading_WithInvalidAssembly_ShouldHandleErrorsGracefully()
    {
        // Arrange
        _output.WriteLine("Test: Error handling for invalid plugin loading");

        var invalidAssemblyPath = "/path/to/nonexistent/assembly.dll";

        // Act & Assert
        var exception = await Assert.ThrowsAsync<PluginLoadException>(async () =>
        {
            await _pluginLoader.LoadPluginAsync<IPlugin>(
                invalidAssemblyPath,
                "NonExistent.Plugin.Type");
        });

        Assert.NotNull(exception);
        Assert.Contains(invalidAssemblyPath, exception.Message);
        Assert.Equal(invalidAssemblyPath, exception.AssemblyPath);

        _output.WriteLine($"Error handling test completed successfully:");
        _output.WriteLine($"  Exception type: {exception.GetType().Name}");
        _output.WriteLine($"  Exception message: {exception.Message}");
    }

    [Fact]
    public async Task PluginValidator_WithSchemaValidation_ShouldValidateDataCorrectly()
    {
        // Arrange
        _output.WriteLine("Test: Plugin schema validation");

        var validator = _serviceProvider.GetRequiredService<TemplatePluginValidator>();
        var schemaFactory = _serviceProvider.GetRequiredService<ISchemaFactory>();
        var arrayRowFactory = _serviceProvider.GetRequiredService<IArrayRowFactory>();

        // Create test schema and data
        var schema = schemaFactory.CreateSchema(new[]
        {
            new ColumnDefinition { Name = "id", DataType = typeof(int), IsNullable = false, Index = 0 },
            new ColumnDefinition { Name = "name", DataType = typeof(string), IsNullable = false, Index = 1 },
            new ColumnDefinition { Name = "value", DataType = typeof(double), IsNullable = false, Index = 2 }
        });

        var validRow = arrayRowFactory.CreateRow(schema, new object[] { 1, "Test", 100.5 });
        var invalidRow = arrayRowFactory.CreateRow(schema, new object[] { "invalid", 123, "not_a_number" });

        // Act
        var validResult = validator.ValidateSchema(schema);
        var validRowResult = await validator.ValidateDataAsync(validRow);
        var invalidRowResult = await validator.ValidateDataAsync(invalidRow);

        // Assert
        Assert.True(validResult.IsValid, $"Schema should be valid: {string.Join(", ", validResult.Errors)}");
        Assert.True(validRowResult.IsValid, $"Valid row should pass validation: {string.Join(", ", validRowResult.Errors)}");
        Assert.False(invalidRowResult.IsValid, "Invalid row should fail validation");

        _output.WriteLine("Schema validation test completed:");
        _output.WriteLine($"  Schema validation: {(validResult.IsValid ? "PASS" : "FAIL")}");
        _output.WriteLine($"  Valid row validation: {(validRowResult.IsValid ? "PASS" : "FAIL")}");
        _output.WriteLine($"  Invalid row validation: {(invalidRowResult.IsValid ? "FAIL" : "PASS")} (expected)");
        
        if (!invalidRowResult.IsValid)
        {
            _output.WriteLine($"  Validation errors: {string.Join(", ", invalidRowResult.Errors)}");
        }
    }

    [Fact]
    public async Task MultiplePlugins_WithConcurrentLoading_ShouldHandleConcurrencyCorrectly()
    {
        // Arrange
        _output.WriteLine("Test: Concurrent plugin loading");

        var loadingTasks = new List<Task<IPlugin>>();
        const int concurrentLoads = 5;

        // Act - Load multiple plugin instances concurrently
        for (int i = 0; i < concurrentLoads; i++)
        {
            var task = _pluginLoader.LoadPluginAsync<IPlugin>(
                _templatePluginAssemblyPath,
                typeof(TemplatePlugin).FullName!);
            loadingTasks.Add(task);
        }

        var plugins = await Task.WhenAll(loadingTasks);

        // Initialize all plugins
        var initializationTasks = plugins.Select(async (plugin, index) =>
        {
            var config = new TemplatePluginConfiguration
            {
                RowCount = 10 * (index + 1), // Different row counts
                BatchSize = 5,
                DataType = $"Concurrent Test Data {index + 1}"
            };
            await plugin.InitializeAsync(config);
            return plugin;
        });

        var initializedPlugins = await Task.WhenAll(initializationTasks);

        // Assert
        Assert.Equal(concurrentLoads, plugins.Length);
        Assert.All(plugins, plugin => Assert.NotNull(plugin));
        Assert.All(initializedPlugins, plugin => 
            Assert.Equal(PluginLifecycleState.Initialized, plugin.LifecycleState));

        // Verify each plugin has unique ID
        var pluginIds = plugins.Select(p => p.Id).ToList();
        Assert.Equal(pluginIds.Count, pluginIds.Distinct().Count());

        _output.WriteLine($"Concurrent loading test completed successfully:");
        _output.WriteLine($"  Plugins loaded: {plugins.Length}");
        _output.WriteLine($"  Unique plugin IDs: {pluginIds.Distinct().Count()}");
        _output.WriteLine($"  All plugins initialized: {initializedPlugins.All(p => p.LifecycleState == PluginLifecycleState.Initialized)}");
    }

    public void Dispose()
    {
        _output.WriteLine("Disposing test resources...");
        _serviceProvider?.Dispose();
    }
}