using FlowEngine.Abstractions.Plugins;
using FlowEngine.Core;
using FlowEngine.Core.Plugins;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Phase3TemplatePlugin;
using Xunit;
using Xunit.Abstractions;

namespace FlowEngine.Integration.Tests;

/// <summary>
/// Integration tests for plugin error handling, retry mechanisms, and resilience patterns.
/// Tests the robustness of the plugin system under various failure scenarios.
/// </summary>
public class PluginErrorHandlingIntegrationTests : IDisposable
{
    private readonly ITestOutputHelper _output;
    private readonly ServiceProvider _serviceProvider;
    private readonly IPluginLoader _pluginLoader;
    private readonly string _templatePluginAssemblyPath;

    public PluginErrorHandlingIntegrationTests(ITestOutputHelper output)
    {
        _output = output;

        // Configure service provider with error handling infrastructure
        var services = new ServiceCollection();
        services.AddLogging(builder => 
        {
            builder.AddConsole();
            builder.SetMinimumLevel(LogLevel.Debug);
        });

        // Add FlowEngine services with error handling
        services.AddFlowEngine();

        // Add retry policy
        services.AddTransient<IRetryPolicy, ExponentialBackoffRetryPolicy>();

        // Note: ResilientPluginLoader would be configured at the application level
        // For testing, we'll use the standard plugin loader with error handling

        _serviceProvider = services.BuildServiceProvider();
        _pluginLoader = _serviceProvider.GetRequiredService<IPluginLoader>();
        _templatePluginAssemblyPath = typeof(TemplatePlugin).Assembly.Location;

        _output.WriteLine($"Error handling test setup complete. Plugin assembly: {_templatePluginAssemblyPath}");
    }

    [Fact]
    public async Task PluginLoading_WithFileNotFound_ShouldProvideDetailedErrorContext()
    {
        // Arrange
        _output.WriteLine("Test: File not found error handling");

        var nonExistentPath = "/path/to/nonexistent/plugin.dll";

        // Act & Assert
        var exception = await Assert.ThrowsAsync<PluginLoadException>(async () =>
        {
            await _pluginLoader.LoadPluginAsync<IPlugin>(
                nonExistentPath,
                "SomePlugin.Type");
        });

        // Verify error context is comprehensive
        Assert.NotNull(exception);
        Assert.Equal(nonExistentPath, exception.AssemblyPath);
        Assert.Equal("SomePlugin.Type", exception.TypeName);
        Assert.NotNull(exception.Context);
        Assert.True(exception.Context.ContainsKey("ErrorContext"));

        _output.WriteLine($"Error handling verification successful:");
        _output.WriteLine($"  Exception type: {exception.GetType().Name}");
        _output.WriteLine($"  Assembly path: {exception.AssemblyPath}");
        _output.WriteLine($"  Type name: {exception.TypeName}");
        _output.WriteLine($"  Context keys: {string.Join(", ", exception.Context.Keys)}");
    }

    [Fact]
    public async Task PluginLoading_WithInvalidTypeName_ShouldProvideTypeSpecificError()
    {
        // Arrange
        _output.WriteLine("Test: Invalid type name error handling");

        var invalidTypeName = "NonExistent.Invalid.Type";

        // Act & Assert
        var exception = await Assert.ThrowsAsync<PluginLoadException>(async () =>
        {
            await _pluginLoader.LoadPluginAsync<IPlugin>(
                _templatePluginAssemblyPath,
                invalidTypeName);
        });

        // Verify error context includes type resolution failure details
        Assert.NotNull(exception);
        Assert.Equal(_templatePluginAssemblyPath, exception.AssemblyPath);
        Assert.Equal(invalidTypeName, exception.TypeName);
        Assert.Contains("type", exception.Message.ToLowerInvariant());

        _output.WriteLine($"Type resolution error verified:");
        _output.WriteLine($"  Error message: {exception.Message}");
        _output.WriteLine($"  Inner exception: {exception.InnerException?.GetType().Name ?? "None"}");
    }

    [Fact]
    public async Task PluginInitialization_WithInvalidConfiguration_ShouldFailGracefully()
    {
        // Arrange
        _output.WriteLine("Test: Invalid configuration error handling");

        var plugin = await _pluginLoader.LoadPluginAsync<IPlugin>(
            _templatePluginAssemblyPath,
            typeof(TemplatePlugin).FullName!);

        // Create invalid configuration (negative values)
        var invalidConfig = new TemplatePluginConfiguration
        {
            RowCount = -100,  // Invalid
            BatchSize = -50,  // Invalid
            DataType = ""     // Invalid empty string
        };

        // Act & Assert
        var exception = await Assert.ThrowsAsync<PluginConfigurationException>(async () =>
        {
            await plugin.InitializeAsync(invalidConfig);
        });

        Assert.NotNull(exception);
        Assert.Contains("RowCount", exception.Message);

        _output.WriteLine($"Configuration validation error verified:");
        _output.WriteLine($"  Error message: {exception.Message}");
        _output.WriteLine($"  Plugin state: {plugin.LifecycleState}");
    }

    [Fact]
    public async Task PluginManager_WithCorruptedManifest_ShouldSkipAndContinue()
    {
        // Arrange
        _output.WriteLine("Test: Corrupted manifest handling");

        var tempDirectory = Path.Combine(Path.GetTempPath(), $"plugin_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(tempDirectory);

        try
        {
            // Create corrupted plugin.json file
            var corruptedManifestPath = Path.Combine(tempDirectory, "plugin.json");
            await File.WriteAllTextAsync(corruptedManifestPath, "{ invalid json content $$$ }");

            // Also copy a valid plugin
            var validPluginDir = Path.Combine(tempDirectory, "valid");
            Directory.CreateDirectory(validPluginDir);
            File.Copy(_templatePluginAssemblyPath, Path.Combine(validPluginDir, Path.GetFileName(_templatePluginAssemblyPath)));
            
            var validManifestPath = Path.Combine(validPluginDir, "plugin.json");
            var validManifest = """
            {
              "id": "valid-test-plugin",
              "name": "Valid Test Plugin",
              "version": "1.0.0",
              "pluginType": "Source",
              "assemblyPath": "Phase3TemplatePlugin.dll",
              "typeName": "Phase3TemplatePlugin.TemplatePlugin"
            }
            """;
            await File.WriteAllTextAsync(validManifestPath, validManifest);

            var discoveryService = _serviceProvider.GetRequiredService<IPluginDiscoveryService>();

            // Act
            var discoveredPlugins = await discoveryService.DiscoverPluginsAsync(tempDirectory);

            // Assert - Should discover the valid plugin and skip the corrupted one
            Assert.NotEmpty(discoveredPlugins);
            var validPlugin = discoveredPlugins.FirstOrDefault(p => p.Id == "valid-test-plugin");
            Assert.NotNull(validPlugin);

            _output.WriteLine($"Corrupted manifest handling successful:");
            _output.WriteLine($"  Total discovered plugins: {discoveredPlugins.Count()}");
            _output.WriteLine($"  Valid plugin found: {validPlugin.Name}");
        }
        finally
        {
            // Cleanup
            if (Directory.Exists(tempDirectory))
            {
                Directory.Delete(tempDirectory, recursive: true);
            }
        }
    }

    [Fact]
    public async Task PluginExecution_WithCancellation_ShouldStopGracefully()
    {
        // Arrange
        _output.WriteLine("Test: Plugin cancellation handling");

        var plugin = await _pluginLoader.LoadPluginAsync<ISourcePlugin>(
            _templatePluginAssemblyPath,
            typeof(TemplatePlugin).FullName!);

        var configuration = new TemplatePluginConfiguration
        {
            RowCount = 10000, // Large number to test cancellation
            BatchSize = 100,
            DataType = "Cancellation Test Data",
            DelayMs = 10 // Small delay to allow cancellation
        };

        await plugin.InitializeAsync(configuration);
        await plugin.StartAsync();

        // Act - Start processing and cancel after short time
        var cancellationTokenSource = new CancellationTokenSource(TimeSpan.FromMilliseconds(500));
        var processedChunks = 0;

        try
        {
            await foreach (var chunk in plugin.ProduceAsync(cancellationTokenSource.Token))
            {
                processedChunks++;
                _output.WriteLine($"Processed chunk {processedChunks} with {chunk.RowCount} rows");
            }
        }
        catch (OperationCanceledException)
        {
            _output.WriteLine("Plugin processing cancelled as expected");
        }

        // Cleanup
        await plugin.StopAsync();

        // Assert
        Assert.True(processedChunks > 0, "Should have processed at least one chunk before cancellation");
        Assert.Equal(PluginLifecycleState.Stopped, plugin.LifecycleState);

        _output.WriteLine($"Cancellation test completed:");
        _output.WriteLine($"  Chunks processed before cancellation: {processedChunks}");
        _output.WriteLine($"  Final plugin state: {plugin.LifecycleState}");
    }

    [Fact]
    public async Task MultiplePlugins_WithOneFailure_ShouldNotAffectOthers()
    {
        // Arrange
        _output.WriteLine("Test: Plugin isolation during failures");

        var pluginManager = _serviceProvider.GetRequiredService<IPluginManager>();

        // Register multiple plugins in a test directory
        var tempDirectory = Path.Combine(Path.GetTempPath(), $"plugin_isolation_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(tempDirectory);

        try
        {
            // Copy template plugin multiple times with different manifests
            for (int i = 1; i <= 3; i++)
            {
                var pluginDir = Path.Combine(tempDirectory, $"plugin{i}");
                Directory.CreateDirectory(pluginDir);
                
                File.Copy(_templatePluginAssemblyPath, 
                    Path.Combine(pluginDir, Path.GetFileName(_templatePluginAssemblyPath)));

                var manifest = $$"""
                {
                  "id": "test-plugin-{{i}}",
                  "name": "Test Plugin {{i}}",
                  "version": "1.0.0",
                  "pluginType": "Source",
                  "assemblyPath": "{{Path.GetFileName(_templatePluginAssemblyPath)}}",
                  "typeName": "{{typeof(TemplatePlugin).FullName}}"
                }
                """;
                
                await File.WriteAllTextAsync(Path.Combine(pluginDir, "plugin.json"), manifest);
            }

            await pluginManager.DiscoverAndRegisterPluginsAsync(tempDirectory);
            var registeredPlugins = pluginManager.GetRegisteredPlugins().ToList();

            Assert.Equal(3, registeredPlugins.Count);

            // Load all plugins
            var loadedPlugins = new List<ISourcePlugin>();
            foreach (var pluginInfo in registeredPlugins)
            {
                var plugin = await pluginManager.LoadPluginAsync<ISourcePlugin>(pluginInfo.Id);
                loadedPlugins.Add(plugin);
            }

            // Initialize first two plugins successfully
            var config1 = new TemplatePluginConfiguration { RowCount = 10, BatchSize = 5, DataType = "Test1" };
            var config2 = new TemplatePluginConfiguration { RowCount = 20, BatchSize = 10, DataType = "Test2" };
            var invalidConfig = new TemplatePluginConfiguration { RowCount = -1, BatchSize = -1, DataType = "" }; // Invalid

            await loadedPlugins[0].InitializeAsync(config1);
            await loadedPlugins[1].InitializeAsync(config2);

            // Third plugin should fail initialization
            var initException = await Assert.ThrowsAsync<PluginConfigurationException>(async () =>
            {
                await loadedPlugins[2].InitializeAsync(invalidConfig);
            });

            // Assert - First two plugins should still be functional
            Assert.Equal(PluginLifecycleState.Initialized, loadedPlugins[0].LifecycleState);
            Assert.Equal(PluginLifecycleState.Initialized, loadedPlugins[1].LifecycleState);
            Assert.Equal(PluginLifecycleState.Created, loadedPlugins[2].LifecycleState); // Failed initialization

            // Test that good plugins can still start
            await loadedPlugins[0].StartAsync();
            await loadedPlugins[1].StartAsync();

            Assert.Equal(PluginLifecycleState.Running, loadedPlugins[0].LifecycleState);
            Assert.Equal(PluginLifecycleState.Running, loadedPlugins[1].LifecycleState);

            _output.WriteLine($"Plugin isolation test completed:");
            _output.WriteLine($"  Loaded plugins: {loadedPlugins.Count}");
            _output.WriteLine($"  Successful initializations: 2");
            _output.WriteLine($"  Failed initializations: 1");
            _output.WriteLine($"  Good plugins still running: {loadedPlugins.Take(2).All(p => p.LifecycleState == PluginLifecycleState.Running)}");

            // Cleanup running plugins
            await loadedPlugins[0].StopAsync();
            await loadedPlugins[1].StopAsync();
        }
        finally
        {
            if (Directory.Exists(tempDirectory))
            {
                Directory.Delete(tempDirectory, recursive: true);
            }
        }
    }

    [Fact]
    public async Task ResilientPluginLoader_WithTransientFailures_ShouldRetryAndSucceed()
    {
        // This test would require a mock scenario where loading fails initially but succeeds on retry
        // For now, we'll test that the resilient loader handles successful cases correctly
        
        _output.WriteLine("Test: Resilient plugin loader basic functionality");

        // Act
        var plugin = await _pluginLoader.LoadPluginAsync<IPlugin>(
            _templatePluginAssemblyPath,
            typeof(TemplatePlugin).FullName!);

        // Assert
        Assert.NotNull(plugin);
        Assert.IsType<TemplatePlugin>(plugin);

        _output.WriteLine($"Resilient plugin loader test completed:");
        _output.WriteLine($"  Plugin loaded successfully: {plugin.GetType().Name}");
        _output.WriteLine($"  Plugin ID: {plugin.Id}");
    }

    [Fact]
    public async Task PluginManager_WithMemoryPressure_ShouldHandleGracefully()
    {
        // Arrange
        _output.WriteLine("Test: Plugin behavior under memory pressure");

        var pluginManager = _serviceProvider.GetRequiredService<IPluginManager>();
        var tempDirectory = Path.Combine(Path.GetTempPath(), $"memory_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(tempDirectory);

        try
        {
            // Create plugin directory
            File.Copy(_templatePluginAssemblyPath, 
                Path.Combine(tempDirectory, Path.GetFileName(_templatePluginAssemblyPath)));

            var manifest = $$"""
            {
              "id": "memory-test-plugin",
              "name": "Memory Test Plugin",
              "version": "1.0.0",
              "pluginType": "Source",
              "assemblyPath": "{{Path.GetFileName(_templatePluginAssemblyPath)}}",
              "typeName": "{{typeof(TemplatePlugin).FullName}}"
            }
            """;
            
            await File.WriteAllTextAsync(Path.Combine(tempDirectory, "plugin.json"), manifest);

            // Load plugin and configure for large data generation
            await pluginManager.DiscoverAndRegisterPluginsAsync(tempDirectory);
            var plugin = await pluginManager.LoadPluginAsync<ISourcePlugin>("memory-test-plugin");

            var config = new TemplatePluginConfiguration
            {
                RowCount = 100000, // Large dataset
                BatchSize = 10000,  // Large batches
                DataType = "Memory Pressure Test"
            };

            await plugin.InitializeAsync(config);

            // Force garbage collection before test
            GC.Collect();
            GC.WaitForPendingFinalizers();
            var initialMemory = GC.GetTotalMemory(false);

            // Act - Process some data under memory pressure
            await plugin.StartAsync();
            var chunksProcessed = 0;
            var cancellationToken = new CancellationTokenSource(TimeSpan.FromSeconds(5)).Token;

            try
            {
                await foreach (var chunk in plugin.ProduceAsync(cancellationToken))
                {
                    chunksProcessed++;
                    
                    // Simulate memory pressure
                    if (chunksProcessed % 5 == 0)
                    {
                        GC.Collect();
                    }
                    
                    if (chunksProcessed >= 10) break; // Limit processing
                }
            }
            catch (OperationCanceledException)
            {
                // Expected timeout
            }

            await plugin.StopAsync();

            var finalMemory = GC.GetTotalMemory(true);

            // Assert
            Assert.True(chunksProcessed > 0, "Should have processed at least some chunks");
            Assert.Equal(PluginLifecycleState.Stopped, plugin.LifecycleState);

            _output.WriteLine($"Memory pressure test completed:");
            _output.WriteLine($"  Chunks processed: {chunksProcessed}");
            _output.WriteLine($"  Initial memory: {initialMemory:N0} bytes");
            _output.WriteLine($"  Final memory: {finalMemory:N0} bytes");
            _output.WriteLine($"  Plugin handled memory pressure gracefully");
        }
        finally
        {
            if (Directory.Exists(tempDirectory))
            {
                Directory.Delete(tempDirectory, recursive: true);
            }
        }
    }

    public void Dispose()
    {
        _output.WriteLine("Disposing error handling test resources...");
        _serviceProvider?.Dispose();
    }
}